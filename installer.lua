if fs.exists("./system/fossil/bootload.lua") then error("System already installed!") return;end;for a, b in pairs(textutils.unserializeJSON("[{\"a\":\"system\\\\fossil\\\\bootload.lua\",\"b\":\"local enableDebug = false;\\r\\nrequire(\\\".system.fossil.F\\\")\\r\\n\\r\\n-- load globals\\r\\nfor i, value in pairs(fs.list(F.PATHS.DIR.global)) do\\r\\n    local path = value:gsub(\\\".lua\\\", \\\"\\\")\\r\\n    require(fs.combine(\\\"../\\\", F.PATHS.DIR.global, path))\\r\\nend\\r\\n\\r\\n-- so fell doesn't crash\\r\\nif os.getComputerLabel() == nil then\\r\\n    os.setComputerLabel(\\\"computer\\\")\\r\\nend\\r\\n\\r\\nif enableDebug then\\r\\n    -- setup defailt console\\r\\n    local w, h = term.getSize();\\r\\n    _G.console = CONSOLE.createConsole(window.create(term.current(), 1, 1, w / 2 - 1, h), 0);\\r\\n    console.clear();\\r\\n\\r\\n    -- logger to debug\\r\\n    _G.logger = CONSOLE.createConsole(window.create(term.current(), w / 2, 1, w / 2 - 1, h), 1);\\r\\n    _G.logger.clear();\\r\\nelse\\r\\n    local w, h = term.getSize();\\r\\n    _G.console = CONSOLE.createConsole(window.create(term.current(), 1, 1, w, h), 0);\\r\\n    console.clear();\\r\\nend\\r\\n\\r\\n-- print header\\r\\nlocal name, version      = F.getName();\\r\\nlocal license, copyright = F.getLicenseCopyright();\\r\\nconsole.log(CONSOLE.getColorSymbol(\\\"yellow\\\") .. name .. \\\"\\\\t\\\" .. version)\\r\\nconsole.log(license .. \\\"\\\\t\\\" .. copyright .. CONSOLE.getColorSymbol(\\\"white\\\"))\\r\\n\\r\\n-- start fell\\r\\nfell.startInstance(\\\"0\\\")\\r\\n\\r\\n-- start threading\\r\\nthreading.Start();\\r\\nthreading.End();\\r\\n\"},{\"a\":\"system\\\\fossil\\\\commands\\\\clear.lua\",\"b\":\"console.clear()\"},{\"a\":\"system\\\\fossil\\\\commands\\\\clearh.lua\",\"b\":\"fell.clearCommandHistory()\"},{\"a\":\"system\\\\fossil\\\\commands\\\\git.lua\",\"b\":\"local function printUsage()\\r\\n    local programName = fs.getName(shell.getRunningProgram():gsub(\\\".lua\\\", \\\"\\\"))\\r\\n    console.log(\\\"Usages:\\\")\\r\\n    console.log(programName .. \\\" get <code> <filename>\\\")\\r\\n    console.log(programName .. \\\" run <code> <arguments>\\\")\\r\\nend\\r\\n\\r\\nlocal args = { ... }\\r\\n\\r\\nif #args < 2 then\\r\\n    printUsage()\\r\\n    return\\r\\nend\\r\\n\\r\\nif not http then\\r\\n    printError(\\\"Git requires the http API\\\")\\r\\n    printError(\\\"Set http.enabled to true in the config\\\")\\r\\n    return\\r\\nend\\r\\n\\r\\nrequire(F.PATHS.DIR.programs .. \\\"git\\\")\\r\\n\\r\\nif args[1] == \\\"get\\\" then\\r\\n    if #args == 2 then\\r\\n        args[3] = F.PATHS.downloads\\r\\n    end\\r\\n    local sPath = shell.resolve(args[3]);\\r\\n\\r\\n    local res = git.get(args[2])\\r\\n    if res then\\r\\n        util.fs.writeFile(sPath, res)\\r\\n\\r\\n        console.log(\\\"Downloaded at \\\" .. sPath)\\r\\n    end\\r\\nelseif args[1] == \\\"run\\\" then\\r\\n    git.run(args[2])\\r\\nelse\\r\\n    printUsage()\\r\\n    return\\r\\nend\\r\\n\"},{\"a\":\"system\\\\fossil\\\\commands\\\\help.lua\",\"b\":\"\"},{\"a\":\"system\\\\fossil\\\\commands\\\\pkg.lua\",\"b\":\"local function printUsage()\\r\\n    local programName = fs.getName(shell.getRunningProgram():gsub(\\\".lua\\\", \\\"\\\"))\\r\\n    console.log(\\\"Usages:\\\")\\r\\n    console.log(programName .. \\\" in <name>\\\")\\r\\n    console.log(\\\"\\\\tInstalls the package.\\\")\\r\\n    console.log(programName .. \\\" un <name>\\\")\\r\\n    console.log(\\\"\\\\tUninstalls the package.\\\")\\r\\n    console.log(programName .. \\\" mk <directory>\\\")\\r\\n    console.log(\\\"\\\\tCompiles a local package.\\\")\\r\\n    console.log(programName .. \\\" ls\\\")\\r\\n    console.log(\\\"\\\\tLists all local packages.\\\")\\r\\n    console.log(programName .. \\\" sr <name>\\\")\\r\\n    console.log(\\\"\\\\tSearches for a package online.\\\")\\r\\n    console.log(programName .. \\\" scan\\\")\\r\\n    console.log(\\\"\\\\tScans local packages for metadata errors.\\\")\\r\\nend\\r\\n\\r\\nlocal args = { ... }\\r\\n\\r\\nif #args < 1 then\\r\\n    printUsage()\\r\\n    return\\r\\nend\\r\\n\\r\\nif not http then\\r\\n    printError(\\\"Package manager requires the http API\\\")\\r\\n    printError(\\\"Set http.enabled to true in the config\\\")\\r\\n    return\\r\\nend\\r\\n\\r\\nrequire(F.PATHS.DIR.programs .. \\\"pkgmngr\\\")\\r\\n\\r\\nif args[1] == \\\"in\\\" then\\r\\n    pkgmngr.packageList.install(args[2], false)\\r\\nelseif args[1] == \\\"un\\\" then\\r\\n    pkgmngr.packageLocal.uninstall(args[2])\\r\\nelseif args[1] == \\\"sr\\\" then\\r\\n    console.log(table.concat(util.table.map(pkgmngr.packageList.findByName(args[2]), function(e)\\r\\n        return e.meta.name .. \\\" \\\" .. (e.meta.displayName or \\\"nil\\\") .. \\\" -> \\\" .. (e.meta.version or \\\"nil\\\")\\r\\n    end), \\\"\\\\n\\\"))\\r\\n    console.log(table.concat(util.table.map(pkgmngr.packageList.findByTag(args[2]), function(e)\\r\\n        return e.meta.name .. \\\" \\\" .. (e.meta.displayName or \\\"nil\\\") .. \\\" -> \\\" .. (e.meta.version or \\\"nil\\\")\\r\\n    end), \\\"\\\\n\\\"))\\r\\nelseif args[1] == \\\"ls\\\" then\\r\\n    console.write(table.concat(util.table.map(pkgmngr.packageLocal.getPaths(), function(e)\\r\\n        local meta = textutils.unserializeJSON(util.fs.readFile(e));\\r\\n\\r\\n        return meta.name .. \\\" \\\" .. (meta.displayName or \\\"nil\\\") .. \\\" -> \\\" .. (meta.version or \\\"nil\\\")\\r\\n    end), \\\"\\\\n\\\"), \\\"\\\\n\\\")\\r\\nelseif args[1] == \\\"scan\\\" then\\r\\n    console.write(\\\"Scanning...\\\\n\\\")\\r\\n    local locals = pkgmngr.packageLocal.scanAll()\\r\\n    local counter = 0;\\r\\n\\r\\n    for key, value in pairs(locals) do\\r\\n        if value.status == \\\"success\\\" then\\r\\n            console.write(value.message .. \\\"\\\\n\\\")\\r\\n        elseif value.status == \\\"partial\\\" then\\r\\n            console.warn(value.message .. \\\"\\\\n\\\")\\r\\n        elseif value.status == \\\"failed\\\" then\\r\\n            printError(value.message .. \\\"\\\\n\\\")\\r\\n        else\\r\\n            console.write(value.message .. \\\"\\\\n\\\")\\r\\n        end\\r\\n        counter = counter + 1;\\r\\n    end\\r\\n\\r\\n    console.write(\\\"Done scanning \\\" .. counter .. \\\" packages.\\\\n\\\")\\r\\nelseif args[1] == \\\"mk\\\" then\\r\\n    pkgmngr.packageLocal.compilePackage(args[2], false)\\r\\nelse\\r\\n    printUsage()\\r\\nend\\r\\n\"},{\"a\":\"system\\\\fossil\\\\commands\\\\szip.lua\",\"b\":\"local function printUsage()\\r\\n    local programName = fs.getName(shell.getRunningProgram():gsub(\\\".lua\\\", \\\"\\\"))\\r\\n    console.log(\\\"Usages:\\\\n\\\")\\r\\n    console.log(programName .. \\\" pack <filepath> <destination>\\\")\\r\\n    console.log(programName .. \\\" unpack <filepath> <destination>\\\")\\r\\nend\\r\\n\\r\\nlocal args = { ... }\\r\\n\\r\\nif #args < 3 then\\r\\n    printUsage()\\r\\n    return\\r\\nend\\r\\n\\r\\nrequire(F.PATHS.DIR.programs .. \\\"sziplib\\\")\\r\\n\\r\\nif args[1] == \\\"pack\\\" then\\r\\n    SZIP.packFiles(args[2], args[3])\\r\\n    return\\r\\nelseif args[1] == \\\"unpack\\\" then\\r\\n    SZIP.unpackFiles(args[2], args[3])\\r\\n    return\\r\\nelse\\r\\n    printUsage()\\r\\n    return\\r\\nend\\r\\n\"},{\"a\":\"system\\\\fossil\\\\F.lua\",\"b\":\"F = {\\r\\n    getName = function()\\r\\n        return \\\"FossilOS\\\", \\\"1.0.0\\\"\\r\\n    end,\\r\\n    getLicenseCopyright = function()\\r\\n        local fileStream = fs.open(F.PATHS.FILE.license, \\\"r\\\");\\r\\n        local a, _, b, c = fileStream.readLine(), fileStream.readLine(), fileStream.readLine(), fileStream.readAll();\\r\\n        fileStream.close();\\r\\n        return a, b, c;\\r\\n    end,\\r\\n    PATHS = {\\r\\n        this = \\\"./system/fossil/F\\\",\\r\\n        global = \\\"./system/fossil/global/\\\",\\r\\n        commands = \\\"./system/fossil/commands/\\\",\\r\\n        commands_fossil = \\\"./system/commands/\\\",\\r\\n\\r\\n        programs = \\\"./system/fossil/programs/\\\",\\r\\n        packages = \\\"./system/packages/\\\",\\r\\n        downloads = \\\"./system/downloads/\\\",\\r\\n        settings = \\\"./system/fossil/.settings\\\",\\r\\n        license = \\\"./system/fossil/LICENSE\\\"\\r\\n    },\\r\\n    settings = {\\r\\n        set = function(name, value)\\r\\n            local s = nil\\r\\n\\r\\n            local success, result = pcall(util.fs.readFile, F.PATHS.FILE.settings)\\r\\n\\r\\n            if not success then\\r\\n                s = {};\\r\\n            else\\r\\n                s = textutils.unserialise(result);\\r\\n            end\\r\\n\\r\\n            s[name] = value;\\r\\n            util.fs.writeFile(F.PATHS.FILE.settings, textutils.serialise(s))\\r\\n        end,\\r\\n        get = function(name, default)\\r\\n            local success, result = pcall(util.fs.readFile, F.PATHS.FILE.settings);\\r\\n\\r\\n            if not success then\\r\\n                F.settings.set(name, default);\\r\\n                return default;\\r\\n            else\\r\\n                s = textutils.unserialise(result);\\r\\n            end\\r\\n\\r\\n            return s[name];\\r\\n        end\\r\\n    }\\r\\n}\\r\\n\\r\\n_G.F = F;\\r\\n\"},{\"a\":\"system\\\\fossil\\\\global\\\\compression.lua\",\"b\":\"local function build_huffman_tree(freq)\\r\\n    local heap = {}\\r\\n    for i, p in pairs(freq) do\\r\\n        heap[#heap + 1] = { char = i, frequency = p }\\r\\n    end\\r\\n    table.sort(heap, function(a, b) return a.frequency < b.frequency end)\\r\\n    while #heap > 1 do\\r\\n        local left = heap[1]\\r\\n        table.remove(heap, 1)\\r\\n        local right = heap[1]\\r\\n        table.remove(heap, 1)\\r\\n        local parent = { char = '', frequency = left.frequency + right.frequency, left = left, right = right }\\r\\n        heap[#heap + 1] = parent\\r\\n        table.sort(heap, function(a, b) return a.frequency < b.frequency end)\\r\\n    end\\r\\n    return heap[1]\\r\\nend\\r\\n\\r\\nlocal function build_huffman_codes(node, prefix, codes)\\r\\n    if node.char ~= '' then\\r\\n        codes[node.char] = prefix\\r\\n        return\\r\\n    end\\r\\n    build_huffman_codes(node.left, prefix * 2, codes)\\r\\n    build_huffman_codes(node.right, prefix * 2 + 1, codes)\\r\\nend\\r\\n\\r\\n_G.compression = {\\r\\n    lzw = {\\r\\n        compress = function(str)\\r\\n            local dict = {}\\r\\n            local output = {}\\r\\n            local phrase = \\\"\\\"\\r\\n            for i = 1, #str do\\r\\n                local c = str:sub(i, i)\\r\\n                local new_phrase = phrase .. c\\r\\n                if dict[new_phrase] then\\r\\n                    phrase = new_phrase\\r\\n                else\\r\\n                    output[#output + 1] = dict[phrase]\\r\\n                    dict[new_phrase] = #dict + 1\\r\\n                    phrase = c\\r\\n                end\\r\\n            end\\r\\n            output[#output + 1] = dict[phrase]\\r\\n            return output\\r\\n        end,\\r\\n        decompress = function(_data)\\r\\n            local _dataObj = textutils.unserialiseJSON(_data)\\r\\n            local compressed_data = _dataObj.o;\\r\\n            local codes = _dataObj.c;\\r\\n\\r\\n            local inverse_codes = {}\\r\\n            for k, v in pairs(codes) do\\r\\n                inverse_codes[v] = k\\r\\n            end\\r\\n            local data = ''\\r\\n            local code = 0\\r\\n            local bits = 0\\r\\n            for i = 1, compressed_data:len() do\\r\\n                code = code * 256 + string.byte(compressed_data:sub(i, i))\\r\\n                bits = bits + 8\\r\\n                while bits >= 8 do\\r\\n                    local char = inverse_codes[math.floor(code % (2 ^ bits / 256)) + 1]\\r\\n                    if char ~= nil then\\r\\n                        data = data .. char\\r\\n                        code = math.floor(code / 256)\\r\\n                        bits = bits - #tostring(codes[char])\\r\\n                    else\\r\\n                        break;\\r\\n                    end\\r\\n                end\\r\\n            end\\r\\n            print(data)\\r\\n\\r\\n            return data\\r\\n        end\\r\\n    },\\r\\n    rle = {\\r\\n        compress = function(data)\\r\\n            local output = \\\"\\\"\\r\\n            local current = data:sub(1, 1)\\r\\n            local count = 1\\r\\n            for i = 2, data:len() do\\r\\n                if data:sub(i, i) == current then\\r\\n                    count = count + 1\\r\\n                else\\r\\n                    output = output .. current .. count\\r\\n                    current = data:sub(i, i)\\r\\n                    count = 1\\r\\n                end\\r\\n            end\\r\\n            output = output .. current .. count\\r\\n            return output\\r\\n        end,\\r\\n        decompress = function(data)\\r\\n            local output = \\\"\\\"\\r\\n            local i = 1\\r\\n            while i <= data:len() do\\r\\n                local char = data:sub(i, i)\\r\\n                i = i + 1\\r\\n                local count = \\\"\\\"\\r\\n                while data:sub(i, i) >= '0' and data:sub(i, i) <= '9' do\\r\\n                    count = count .. data:sub(i, i)\\r\\n                    i = i + 1\\r\\n                end\\r\\n                count = tonumber(count)\\r\\n                for j = 1, count do\\r\\n                    output = output .. char\\r\\n                end\\r\\n            end\\r\\n            return output\\r\\n        end\\r\\n    }\\r\\n}\\r\\n\"},{\"a\":\"system\\\\fossil\\\\global\\\\console.lua\",\"b\":\"local function CONSOLE_FUNC()\\r\\n    local CONSOLES = {};\\r\\n\\r\\n    return {\\r\\n        version = function()\\r\\n            return \\\"1.0.0\\\"\\r\\n        end,\\r\\n        getConsoleById = function(id)\\r\\n            return util.table.find(CONSOLES, function(e)\\r\\n                    return e.id == id;\\r\\n                end)\\r\\n        end,\\r\\n        getConsoleByWind = function(wind)\\r\\n            return util.table.find(CONSOLES, function(e)\\r\\n                    return e.wind == wind;\\r\\n                end)\\r\\n        end,\\r\\n        createConsole = function(_wind, _id, _margins)\\r\\n            local cons = {}\\r\\n\\r\\n            cons = {\\r\\n                id = _id,\\r\\n                wind = _wind,\\r\\n                margins = _margins or {\\r\\n                    top = 0,\\r\\n                    bottom = 0,\\r\\n                    left = 0,\\r\\n                    right = 0\\r\\n                },\\r\\n                input = {\\r\\n                    reading = false,\\r\\n                    string = nil,\\r\\n                    -- number\\r\\n                    textPos = nil,\\r\\n                    tabcompleteIndex = nil,\\r\\n                    historyIndex = nil,\\r\\n                    startCursorX = nil,\\r\\n                    startCursorY = nil,\\r\\n                    read = function(history, tabCompleteFunc, default, textCursor, iscursorcolor)\\r\\n                        if not iscursorcolor then iscursorcolor = true end\\r\\n                        if not textCursor then textCursor = CONSOLE.getColorSymbol(\\\"gray\\\") end\\r\\n\\r\\n                        history = util.table.reverse(history)\\r\\n\\r\\n                        if not reading then\\r\\n                            cons.input.string = default or \\\"\\\";\\r\\n                            cons.input.tabcompleteIndex = 0;\\r\\n                            cons.input.historyIndex = 0;\\r\\n                            cons.input.textPos = 1;\\r\\n                            cons.input.startCursorX, cons.input.startCursorY = cons.wind.getCursorPos();\\r\\n                            reading = true\\r\\n\\r\\n                            if not iscursorcolor then\\r\\n                                cons.write(cons.input.string .. textCursor)\\r\\n                            end\\r\\n                        end\\r\\n\\r\\n                        local w, h = cons.wind.getSize();\\r\\n\\r\\n                        repeat\\r\\n                            local index, eventData = util.pullEventAny(\\\"key\\\", \\\"char\\\")\\r\\n                            local keyChar = eventData[2];\\r\\n\\r\\n                            local tabComplete = tabCompleteFunc(cons.input.string) or {};\\r\\n\\r\\n                            if index == 1 then\\r\\n                                -- #region edit\\r\\n                                if (keyChar == keys.enter or keyChar == keys.right) and (\\r\\n                                    ((cons.input.tabcompleteIndex == 0) and (history[cons.input.historyIndex] ~= nil)) or\\r\\n                                    (tabComplete[cons.input.tabcompleteIndex] ~= nil)\\r\\n                                    )\\r\\n                                then\\r\\n                                    if (cons.input.tabcompleteIndex == 0) and (history[cons.input.historyIndex] ~= nil) then\\r\\n                                        cons.input.string = history[cons.input.historyIndex];\\r\\n\\r\\n                                        cons.input.historyIndex = 0;\\r\\n                                        cons.input.textPos = #cons.input.string + 1\\r\\n                                        keyChar = nil\\r\\n                                    elseif tabComplete[cons.input.tabcompleteIndex] ~= nil then\\r\\n                                        cons.input.string = cons.input.string .. tabComplete\\r\\n                                            [cons.input.tabcompleteIndex];\\r\\n\\r\\n                                        cons.input.tabcompleteIndex = 0;\\r\\n                                        cons.input.textPos = #cons.input.string + 1\\r\\n                                        keyChar = nil\\r\\n                                    end\\r\\n                                elseif keyChar == keys.left then\\r\\n                                    cons.input.textPos = cons.input.textPos - 1\\r\\n                                    if cons.input.textPos < 1 then\\r\\n                                        cons.input.textPos = 1\\r\\n                                    end\\r\\n                                elseif keyChar == keys.right then\\r\\n                                    cons.input.textPos = cons.input.textPos + 1\\r\\n                                    if cons.input.textPos > #cons.input.string + 1 then\\r\\n                                        cons.input.textPos = #cons.input.string + 1\\r\\n                                    end\\r\\n                                    --#endregion\\r\\n                                    --#region history\\r\\n                                elseif keyChar == keys.down then\\r\\n                                    cons.input.historyIndex = cons.input.historyIndex - 1\\r\\n                                    if cons.input.historyIndex < 0 then\\r\\n                                        cons.input.historyIndex = 0\\r\\n                                    end\\r\\n                                    cons.input.tabcompleteIndex = 0\\r\\n                                elseif keyChar == keys.up then\\r\\n                                    cons.input.historyIndex = cons.input.historyIndex + 1\\r\\n                                    if cons.input.historyIndex > #history then\\r\\n                                        cons.input.historyIndex = #history\\r\\n                                    end\\r\\n                                    cons.input.tabcompleteIndex = 0\\r\\n                                    --#endregion\\r\\n                                    --#region complete\\r\\n                                elseif keyChar == keys.tab then\\r\\n                                    cons.input.tabcompleteIndex = cons.input.tabcompleteIndex + 1\\r\\n                                    if cons.input.tabcompleteIndex > #tabComplete then\\r\\n                                        cons.input.tabcompleteIndex = 0\\r\\n                                    end\\r\\n\\r\\n                                    --#endregion\\r\\n                                    --#region edit\\r\\n                                elseif keyChar == keys.backspace then\\r\\n                                    if cons.input.textPos > 1 then\\r\\n                                        cons.input.string = cons.input.string:sub(1, cons.input.textPos - 2) ..\\r\\n                                            cons.input.string:sub(cons.input.textPos);\\r\\n\\r\\n                                        cons.input.textPos = cons.input.textPos - 1\\r\\n                                    end\\r\\n                                elseif keyChar == keys.delete then\\r\\n                                    if cons.input.textPos < #cons.input.string + 1 then\\r\\n                                        cons.input.string = cons.input.string:sub(1, cons.input.textPos - 1) ..\\r\\n                                            cons.input.string:sub(cons.input.textPos + 1);\\r\\n                                    end\\r\\n                                end\\r\\n                                --#endregion\\r\\n                            else\\r\\n                                cons.input.string = cons.input.string:sub(1, cons.input.textPos - 1) ..\\r\\n                                    keyChar .. cons.input.string:sub(cons.input.textPos);\\r\\n                                cons.input.textPos = cons.input.textPos + 1\\r\\n                            end\\r\\n\\r\\n                            cons.wind.setCursorPos(cons.input.startCursorX, cons.input.startCursorY)\\r\\n\\r\\n                            if iscursorcolor then\\r\\n                                cons.write(cons.input.string:sub(1, cons.input.textPos - 1));\\r\\n                                local defaultbkgcol = cons.wind.getBackgroundColor()\\r\\n                                cons.wind.setBackgroundColor(colors[textCursor:sub(2, #textCursor - 1)])\\r\\n\\r\\n                                local c = cons.input.string:sub(cons.input.textPos, cons.input.textPos);\\r\\n\\r\\n                                cons.write(c);\\r\\n\\r\\n                                cons.wind.setBackgroundColor(defaultbkgcol)\\r\\n                                cons.write(cons.input.string:sub(cons.input.textPos + 1));\\r\\n                            else\\r\\n                                cons.write(\\r\\n                                    cons.input.string:sub(1, cons.input.textPos - 1) ..\\r\\n                                    textCursor ..\\r\\n                                    cons.input.string:sub(cons.input.textPos)\\r\\n                                )\\r\\n                            end\\r\\n\\r\\n                            local defaultbkgcol = cons.wind.getBackgroundColor()\\r\\n                            cons.wind.setBackgroundColor(colors.gray)\\r\\n                            if cons.input.tabcompleteIndex == 0 then\\r\\n                                cons.write(history[cons.input.historyIndex] or \\\"\\\")\\r\\n                            else\\r\\n                                cons.write(tabComplete[cons.input.tabcompleteIndex] or \\\"\\\")\\r\\n                            end\\r\\n                            cons.wind.setBackgroundColor(defaultbkgcol)\\r\\n\\r\\n                            local x, _ = cons.wind.getCursorPos();\\r\\n                            cons.write(string.rep(\\\" \\\", w - x))\\r\\n                        until index == 1 and keyChar == keys.enter\\r\\n\\r\\n                        console.log()\\r\\n\\r\\n                        reading = false;\\r\\n                        return cons.input.string;\\r\\n                    end,\\r\\n                },\\r\\n                write = function(...)\\r\\n                    local fullTextString = {}\\r\\n                    for i = 1, #arg, 1 do\\r\\n                        if arg[i] ~= nil then\\r\\n                            table.insert(fullTextString, CONSOLE.ToString(arg[i]));\\r\\n                        end\\r\\n                    end\\r\\n\\r\\n                    fullTextString = table.concat(fullTextString, \\\" \\\") or \\\"\\\"\\r\\n\\r\\n                    if #fullTextString == 0 then\\r\\n                        return;\\r\\n                    end\\r\\n\\r\\n                    local w, h = cons.wind.getSize();\\r\\n\\r\\n                    local color = \\\"\\\"\\r\\n                    local gettingEscapeSymbol = false;\\r\\n                    local disableWrite = false;\\r\\n                    local disableChar = false;\\r\\n                    local i = 1;\\r\\n                    local count = #fullTextString;\\r\\n                    while i <= count do\\r\\n                        local char = fullTextString:sub(i, i);\\r\\n\\r\\n                        if char == CONSOLE.getColorSymbol() then\\r\\n                            gettingEscapeSymbol = not gettingEscapeSymbol;\\r\\n                            disableWrite = gettingEscapeSymbol;\\r\\n\\r\\n                            if gettingEscapeSymbol == false then\\r\\n                                local col = colors[color];\\r\\n                                if col ~= nil then\\r\\n                                    cons.wind.setTextColor(col)\\r\\n                                    disableChar = true\\r\\n                                end\\r\\n                                color = \\\"\\\";\\r\\n                            end\\r\\n                        elseif gettingEscapeSymbol then\\r\\n                            color = color .. fullTextString:sub(i, i)\\r\\n                        end\\r\\n\\r\\n                        if char == \\\"\\\\n\\\" then\\r\\n                            local x, y = cons.wind.getCursorPos();\\r\\n                            cons.wind.setCursorPos(cons.margins.left + 1, y + 1);\\r\\n                            disableChar = true;\\r\\n                        end\\r\\n                        if char == \\\"\\\\t\\\" then\\r\\n                            local tabSize = F.settings.get(\\\"console.tabSize\\\", 3) + 1;\\r\\n                            local x, y = cons.wind.getCursorPos();\\r\\n                            cons.wind.setCursorPos(math.ceil(x / tabSize) * tabSize + 1, y)\\r\\n                            disableChar = true;\\r\\n                        end\\r\\n                        local x, y = cons.wind.getCursorPos();\\r\\n                        if x > w - cons.margins.right then\\r\\n                            cons.wind.setCursorPos(cons.margins.left + 1, y + 1);\\r\\n                        end\\r\\n                        local x, y = cons.wind.getCursorPos();\\r\\n                        if y > h - cons.margins.bottom then\\r\\n                            cons.wind.scroll(1)\\r\\n                            cons.wind.setCursorPos(cons.margins.left + 1, y - 1 - cons.margins.bottom)\\r\\n                        end\\r\\n\\r\\n                        if (not disableWrite) and (not disableChar) then\\r\\n                            cons.wind.write(char)\\r\\n                        end\\r\\n                        disableChar = false\\r\\n\\r\\n                        i = i + 1\\r\\n                    end\\r\\n                end,\\r\\n                log = function(...)\\r\\n                    local a = { ... }\\r\\n                    table.insert(a, \\\"\\\\n\\\")\\r\\n                    cons.write(table.unpack(a))\\r\\n                end,\\r\\n                warn = function(...)\\r\\n                    cons.write(CONSOLE.getColorSymbol(\\\"yellow\\\"))\\r\\n                    cons.log(...)\\r\\n                    cons.write(CONSOLE.getColorSymbol(\\\"white\\\"))\\r\\n                end,\\r\\n                clear = function()\\r\\n                    cons.wind.clear();\\r\\n                    cons.wind.setCursorPos(1, 1);\\r\\n                end,\\r\\n            }\\r\\n\\r\\n            table.insert(CONSOLES, cons);\\r\\n\\r\\n            return cons;\\r\\n        end,\\r\\n        getColorSymbol = function(str)\\r\\n            if str ~= nil then\\r\\n                return CONSOLE.getColorSymbol() .. str .. CONSOLE.getColorSymbol();\\r\\n            end\\r\\n            return \\\"§\\\";\\r\\n        end,\\r\\n        ToString = function(value)\\r\\n            if type(value) == \\\"string\\\" then\\r\\n                return value;\\r\\n            elseif type(value) == \\\"number\\\" then\\r\\n                return tostring(value);\\r\\n            elseif type(value) == \\\"boolean\\\" then\\r\\n                if value then\\r\\n                    return \\\"true\\\"\\r\\n                else\\r\\n                    return \\\"false\\\"\\r\\n                end\\r\\n            elseif type(value) == \\\"table\\\" then\\r\\n                return util.string.trim(textutils.serialise(value):gsub(\\\"\\\\n\\\", \\\"\\\"));\\r\\n            elseif type(value) == \\\"function\\\" then\\r\\n                local info = debug.getinfo(value);\\r\\n                local functionParams = {};\\r\\n\\r\\n                for i = 1, info.nparams, 1 do\\r\\n                    table.insert(functionParams, i, table.concat({ debug.getlocal(value, i) }, \\\": \\\"));\\r\\n                end\\r\\n\\r\\n                return (info.name or \\\"func\\\") .. \\\"(\\\" .. table.concat(functionParams, \\\", \\\") .. \\\")\\\";\\r\\n            elseif type(value) == \\\"nil\\\" or value == nil then\\r\\n                return \\\"nil\\\";\\r\\n            end\\r\\n\\r\\n            return debug.getinfo(value)\\r\\n        end,\\r\\n    }\\r\\nend\\r\\n\\r\\n_G.CONSOLE = CONSOLE_FUNC();\\r\\n\"},{\"a\":\"system\\\\fossil\\\\global\\\\fell.lua\",\"b\":\"local function fell_FUNC()\\r\\n    local commandHistoryPath = fs.combine(F.PATHS.DIR.global, \\\"../.commandHistory\\\");\\r\\n\\r\\n    local fileStream = fs.open(commandHistoryPath, \\\"r\\\");\\r\\n    local history\\r\\n    if fileStream then\\r\\n        history = textutils.unserialize(fileStream.readAll()) or {};\\r\\n        fileStream.close();\\r\\n    else\\r\\n        history = {}\\r\\n    end\\r\\n\\r\\n    return {\\r\\n        version = function()\\r\\n            return \\\"1.0.0\\\";\\r\\n        end,\\r\\n        completionPaths = {\\r\\n            F.PATHS.DIR.commands,\\r\\n            F.PATHS.DIR.commands_fossil,\\r\\n            \\\"rom/programs/\\\",\\r\\n        },\\r\\n        commandHistory = history,\\r\\n        scrollPos = 0,\\r\\n        getCompletionPaths = function()\\r\\n            return util.table.combine(fell.completionPaths, { [#fell.completionPaths + 1] = shell.dir() })\\r\\n        end,\\r\\n        getProgramPath = function(name)\\r\\n            if name ~= nil then\\r\\n                for key, value in pairs(fell.getCompletionPaths()) do\\r\\n                    local completion = fs.complete(name, shell.resolve(value))\\r\\n\\r\\n                    if #completion > 0 then\\r\\n                        if completion[1] == \\\".lua\\\" then\\r\\n                            return fs.combine(shell.resolve(value), name .. completion[1]);\\r\\n                        end\\r\\n                    end\\r\\n                end\\r\\n            end\\r\\n\\r\\n            return nil;\\r\\n        end,\\r\\n        readCommand = function(writePrefix, commandCompletedCallback)\\r\\n            _G.logger.log(CONSOLE.getColorSymbol(\\\"white\\\") .. \\\"$ \\\")\\r\\n            _G.logger.log(\\r\\n                CONSOLE.getColorSymbol(\\\"white\\\") .. \\\"$ \\\"\\r\\n            )\\r\\n\\r\\n            if writePrefix then\\r\\n                console.write(\\r\\n                    CONSOLE.getColorSymbol(\\\"green\\\") ..\\r\\n                    os.getComputerLabel() .. \\\" \\\" ..\\r\\n                    CONSOLE.getColorSymbol(\\\"purple\\\") ..\\r\\n                    fell.version() .. \\\" \\\" ..\\r\\n                    CONSOLE.getColorSymbol(\\\"yellow\\\") .. \\\"~/\\\" ..\\r\\n                    shell.dir() .. \\\"\\\\n\\\" ..\\r\\n                    CONSOLE.getColorSymbol(\\\"white\\\") .. \\\"$ \\\"\\r\\n                )\\r\\n            end\\r\\n            local command = \\\"\\\"\\r\\n\\r\\n            command = console.input.read(fell.commandHistory, fell.complete)\\r\\n\\r\\n            if fell.commandHistory[#fell.commandHistory] ~= command then\\r\\n                table.insert(fell.commandHistory, command)\\r\\n\\r\\n                local fileStream = fs.open(commandHistoryPath, \\\"w\\\");\\r\\n                fileStream.write(textutils.serialize(fell.commandHistory))\\r\\n                fileStream.close();\\r\\n            end\\r\\n\\r\\n            local tokens = fell.fromShell.tokenise(command);\\r\\n            local program = fell.getProgramPath(tokens[1]);\\r\\n            if not program then\\r\\n                console.warn(tokens[1], \\\"command not found!\\\\n\\\")\\r\\n                return;\\r\\n            end\\r\\n\\r\\n            threading.createThread(\\r\\n                function()\\r\\n                    shell.run(program, table.unpack(tokens, 2))\\r\\n                end,\\r\\n                commandCompletedCallback\\r\\n            )\\r\\n            return true;\\r\\n        end,\\r\\n        complete = function(sLine)\\r\\n            if #sLine > 0 then\\r\\n                for key, value in pairs(fell.getCompletionPaths()) do\\r\\n                    local completion = fs.complete(sLine, shell.resolve(value))\\r\\n\\r\\n                    if #completion > 0 then\\r\\n                        return util.table.map(completion, function(e)\\r\\n                                return e:gsub(\\\".lua\\\", \\\"\\\")\\r\\n                            end);\\r\\n                    end\\r\\n                end\\r\\n            end\\r\\n            return nil\\r\\n        end,\\r\\n        clearCommandHistory = function()\\r\\n            local fileStream = fs.open(commandHistoryPath, \\\"w\\\");\\r\\n            fileStream.write(\\\"{\\\\n}\\\")\\r\\n            fileStream.close();\\r\\n        end,\\r\\n        fromShell = {\\r\\n            tokenise = function(...)\\r\\n                local sLine = table.concat({ ... }, \\\" \\\")\\r\\n                local tWords = {}\\r\\n                local bQuoted = false\\r\\n                for match in string.gmatch(sLine .. \\\"\\\\\\\"\\\", \\\"(.-)\\\\\\\"\\\") do\\r\\n                    if bQuoted then\\r\\n                        table.insert(tWords, match)\\r\\n                    else\\r\\n                        for m in string.gmatch(match, \\\"[^ \\\\t]+\\\") do\\r\\n                            table.insert(tWords, m)\\r\\n                        end\\r\\n                    end\\r\\n                    bQuoted = not bQuoted\\r\\n                end\\r\\n                return tWords\\r\\n            end\\r\\n        },\\r\\n        startInstance = function(name)\\r\\n            local runningCommand = false;\\r\\n            local function threadCallback(result, status)\\r\\n                threading.createThread(function()\\r\\n                    if not runningCommand then\\r\\n                        if status == \\\"error\\\" then\\r\\n                            printError(result[1])\\r\\n                        end\\r\\n                        if fell.readCommand(status ~= \\\"timeout\\\", function()\\r\\n                                runningCommand = false;\\r\\n                            end) then\\r\\n                            runningCommand = true;\\r\\n                        end\\r\\n                    end\\r\\n                end, threadCallback, 2)\\r\\n            end\\r\\n\\r\\n            threadCallback()\\r\\n        end,\\r\\n    }\\r\\nend\\r\\n\\r\\n\\r\\n_G.fell = fell_FUNC()\\r\\n\"},{\"a\":\"system\\\\fossil\\\\global\\\\threading.lua\",\"b\":\"local function THREADING_FUNC()\\r\\n    local waitingThreads = {}\\r\\n    local maxThreadTimeout = 256;\\r\\n    local defaultThreadTimeout = 8;\\r\\n    local currentlyThreading = false;\\r\\n\\r\\n    local shouldEnd = false;\\r\\n\\r\\n    local events = {\\r\\n        \\\"fossil.threading.thread.create\\\"\\r\\n    }\\r\\n\\r\\n    return {\\r\\n        Start = function()\\r\\n            parallel.waitForAll(\\r\\n                function()\\r\\n                    while not shouldEnd do\\r\\n                        if (#waitingThreads > 0) and (not currentlyThreading) then\\r\\n                            currentlyThreading = true\\r\\n\\r\\n                            local threads = { table.unpack(waitingThreads) }\\r\\n                            waitingThreads = {};\\r\\n                            parallel.waitForAll(table.unpack(threads))\\r\\n\\r\\n                            currentlyThreading = false;\\r\\n                        end\\r\\n\\r\\n                        sleep(0)\\r\\n                    end\\r\\n                end\\r\\n            )\\r\\n        end,\\r\\n        End = function()\\r\\n            shouldEnd = true;\\r\\n        end,\\r\\n        isThreading = function()\\r\\n            return currentlyThreading;\\r\\n        end,\\r\\n        timeoutFunction = function(func, timeout, ...)\\r\\n            local a = { ... }\\r\\n\\r\\n            return parallel.waitForAny(\\r\\n                    function() sleep(timeout) end,\\r\\n                    function() func(table.unpack(a)) end\\r\\n                ) == 2;\\r\\n        end,\\r\\n        --[[-Creates a thread and adds it to the thread queue.\\r\\n\\r\\n            ---@param action () -> any\\r\\n            ---@param callback (result: any, status: \\\"success\\\"|\\\"error\\\"|\\\"timeout\\\") -> void\\r\\n            ---@param timeout seconds\\r\\n        ]] --\\r\\n        createThread = function(action, callback, timeout)\\r\\n            if timeout == nil then timeout = defaultThreadTimeout end\\r\\n            if timeout > maxThreadTimeout then timeout = maxThreadTimeout end\\r\\n\\r\\n            local t = function()\\r\\n                if not threading.timeoutFunction(\\r\\n                        function()\\r\\n                            local actionResult = { pcall(action) };\\r\\n\\r\\n                            if callback ~= nil then\\r\\n                                if actionResult[1] then\\r\\n                                    callback({ table.unpack(actionResult, 2) }, \\\"success\\\")\\r\\n                                else\\r\\n                                    callback({ table.unpack(actionResult, 2) }, \\\"error\\\")\\r\\n                                end\\r\\n                            end\\r\\n                        end, timeout) then\\r\\n                    if callback ~= nil then\\r\\n                        callback({}, \\\"timeout\\\")\\r\\n                    end\\r\\n                end\\r\\n            end\\r\\n            table.insert(waitingThreads, t)\\r\\n\\r\\n            os.queueEvent(events[1])\\r\\n\\r\\n            return t;\\r\\n        end\\r\\n    }\\r\\nend\\r\\n\\r\\n_G.threading = THREADING_FUNC();\\r\\n\"},{\"a\":\"system\\\\fossil\\\\global\\\\util.lua\",\"b\":\"local function UTILITY_FUNC()\\r\\n    local circleCounts = {\\r\\n        { 1,    1 },\\r\\n        { 2,    6 },\\r\\n        { 3,    8 },\\r\\n        { 4,    12 },\\r\\n        { 6,    16 },\\r\\n        { 7,    20 },\\r\\n        { 9,    24 },\\r\\n        { 11,   28 },\\r\\n        { 13,   32 },\\r\\n        { 14,   36 },\\r\\n        { 16,   40 },\\r\\n        { 18,   44 },\\r\\n        { 19,   48 },\\r\\n        { 21,   52 },\\r\\n        { 23,   56 },\\r\\n        { 25,   60 },\\r\\n        { 27,   64 },\\r\\n        { 28,   68 },\\r\\n        { 30,   72 },\\r\\n        { 32,   76 },\\r\\n        { 33,   80 },\\r\\n        { 35,   84 },\\r\\n        { 37,   88 },\\r\\n        { 38,   92 },\\r\\n        { 40,   96 },\\r\\n        { 41,   100 },\\r\\n        { 43,   104 },\\r\\n        { 45,   108 },\\r\\n        { 47,   112 },\\r\\n        { 49,   116 },\\r\\n        { 51,   120 },\\r\\n        { 53,   124 },\\r\\n        { 54,   128 },\\r\\n        { 56,   132 },\\r\\n        { 58,   136 },\\r\\n        { 59,   140 },\\r\\n        { 61,   144 },\\r\\n        { 63,   148 },\\r\\n        { 65,   152 },\\r\\n        { 66,   148 },\\r\\n        { 68,   160 },\\r\\n        { 69,   156 },\\r\\n        { 71,   164 },\\r\\n        { 72,   168 },\\r\\n        { 73,   172 },\\r\\n        { 75,   176 },\\r\\n        { 76,   180 },\\r\\n        { 79,   188 },\\r\\n        { 82,   196 },\\r\\n        { 86,   204 },\\r\\n        { 90,   212 },\\r\\n        { 95,   220 },\\r\\n        { 100,  228 },\\r\\n        { 106,  236 },\\r\\n        { 113,  244 },\\r\\n        { 120,  252 },\\r\\n        { 129,  260 },\\r\\n        { 139,  268 },\\r\\n        { 152,  276 },\\r\\n        { 166,  284 },\\r\\n        { 184,  292 },\\r\\n        { 207,  300 },\\r\\n        { 236,  308 },\\r\\n        { 275,  316 },\\r\\n        { 330,  324 },\\r\\n        { 412,  332 },\\r\\n        { 548,  340 },\\r\\n        { 822,  348 },\\r\\n        { 1642, 356 },\\r\\n    }\\r\\n    local function FindClosestCircleStep(radius)\\r\\n        local result = circleCounts[#circleCounts][2];\\r\\n\\r\\n        for i = 1, #circleCounts, 1 do\\r\\n            if circleCounts[i][1] > radius then\\r\\n                if i == 1 then\\r\\n                    result = circleCounts[i][2];\\r\\n                else\\r\\n                    result = circleCounts[i - 1][2];\\r\\n                end\\r\\n\\r\\n                break;\\r\\n            end\\r\\n        end\\r\\n\\r\\n        return 360 / result;\\r\\n    end\\r\\n\\r\\n    return {\\r\\n        eval = function(lua_code, ...)\\r\\n            local func, err = load(lua_code, \\\"lua_code\\\", \\\"t\\\", _ENV)\\r\\n            if not func then\\r\\n                error(err)\\r\\n                return\\r\\n            end\\r\\n            local success, msg = pcall(func, select(3, ...))\\r\\n            if not success then\\r\\n                error(msg)\\r\\n            end\\r\\n        end,\\r\\n        pullEventTimeout = function(event, sec)\\r\\n            local result = nil\\r\\n\\r\\n            local function Event()\\r\\n                result = { os.pullEvent(event) }\\r\\n            end\\r\\n\\r\\n            local function Timeout()\\r\\n                sleep(sec)\\r\\n            end\\r\\n\\r\\n            parallel.waitForAny(Event, Timeout)\\r\\n            return result;\\r\\n        end,\\r\\n        pullEventAny = function(...)\\r\\n            local events = {}\\r\\n            local result = {}\\r\\n\\r\\n            for key, value in pairs({...}) do\\r\\n                events[#events + 1] = function()\\r\\n                    result = { os.pullEvent(value) }\\r\\n                end\\r\\n            end\\r\\n\\r\\n            return parallel.waitForAny(table.unpack(events)), result\\r\\n        end,\\r\\n        IteratorToArray = function(itterator)\\r\\n            local result = {}\\r\\n            for value in itterator do\\r\\n                table.insert(result, value);\\r\\n            end\\r\\n            return result;\\r\\n        end,\\r\\n        clone = function(orig)\\r\\n            local orig_type = type(orig)\\r\\n            local copy\\r\\n            if orig_type == 'table' then\\r\\n                copy = {}\\r\\n                for orig_key, orig_value in next, orig, nil do\\r\\n                    copy[util.clone(orig_key)] = util.clone(orig_value)\\r\\n                end\\r\\n                setmetatable(copy, util.clone(getmetatable(orig)))\\r\\n            else\\r\\n                copy = orig\\r\\n            end\\r\\n            return copy\\r\\n        end,\\r\\n        fs = {\\r\\n            writeFile = function(path, data)\\r\\n                local file = fs.open(path, \\\"w\\\");\\r\\n                file.write(data);\\r\\n                file.close();\\r\\n            end,\\r\\n            readFile = function(path)\\r\\n                if not fs.exists(path) then\\r\\n                    error(\\\"File not found! (\\\" .. path .. \\\")\\\")\\r\\n                end\\r\\n                if fs.isDir(path) then\\r\\n                    error(\\\"Cannot read a directory! (\\\" .. path .. \\\")\\\")\\r\\n                end\\r\\n\\r\\n                local file = fs.open(path, \\\"r\\\");\\r\\n                local data = file.readAll();\\r\\n                file.close();\\r\\n                return data;\\r\\n            end,\\r\\n            foreach = function(path, func)\\r\\n                if not fs.exists(path) then\\r\\n                    error(\\\"Path not found! (\\\" .. path .. \\\")\\\")\\r\\n                end\\r\\n\\r\\n                local function t(p)\\r\\n                    local files = fs.list(p)\\r\\n\\r\\n                    for index, value in ipairs(files) do\\r\\n                        local fp = fs.combine(p, value);\\r\\n\\r\\n                        if func(fp) then\\r\\n                            return;\\r\\n                        end\\r\\n\\r\\n                        if fs.isDir(fp) then\\r\\n                            t(fp)\\r\\n                        end\\r\\n                    end\\r\\n                end\\r\\n\\r\\n                t(path);\\r\\n            end,\\r\\n            tree = function(path)\\r\\n                path = shell.resolve(path)\\r\\n\\r\\n                if not fs.exists(path) then\\r\\n                    error(\\\"Path not found! (\\\" .. path .. \\\")\\\")\\r\\n                end\\r\\n\\r\\n                local result = {};\\r\\n\\r\\n                util.fs.foreach(path, function(fp)\\r\\n                    local lfp = fp:gsub(path, \\\"\\\")\\r\\n\\r\\n                    local parent = util.table.getFromPath(result, fs.getDir(lfp))\\r\\n\\r\\n                    if parent then\\r\\n                        if fs.isDir(fp) then\\r\\n                            parent[fs.getName(fp)] = {}\\r\\n                        else\\r\\n                            parent[fs.getName(fp)] = (#util.fs.readFile(fp) * 1E-3) .. \\\" kb\\\"\\r\\n                        end\\r\\n                    end\\r\\n                end)\\r\\n\\r\\n                return result;\\r\\n            end,\\r\\n            findFile = function(path, pattern)\\r\\n                path = shell.resolve(path)\\r\\n\\r\\n                if not fs.exists(path) then\\r\\n                    error(\\\"Path not found! (\\\" .. path .. \\\")\\\")\\r\\n                end\\r\\n\\r\\n                local result = nil\\r\\n\\r\\n                util.fs.foreach(path, function(fp)\\r\\n                    if fs.getName(fp):match(pattern) then\\r\\n                        result = fp;\\r\\n                        return true;\\r\\n                    end\\r\\n                end)\\r\\n\\r\\n                return result;\\r\\n            end,\\r\\n            findFiles = function(path, pattern)\\r\\n                path = shell.resolve(path)\\r\\n\\r\\n                if not fs.exists(path) then\\r\\n                    error(\\\"Path not found! (\\\" .. path .. \\\")\\\")\\r\\n                end\\r\\n\\r\\n                local result = {}\\r\\n\\r\\n                util.fs.foreach(path, function(fp)\\r\\n                    if fs.getName(fp):match(pattern) then\\r\\n                        table.insert(result, fp);\\r\\n                    end\\r\\n                end)\\r\\n\\r\\n                return result;\\r\\n            end\\r\\n        },\\r\\n        table = {\\r\\n            reduce = function(arrayTable, func)\\r\\n                local result = arrayTable[1]\\r\\n                for i = 2, #arrayTable, 1 do\\r\\n                    result = func(result, arrayTable[i])\\r\\n                end\\r\\n                return result;\\r\\n            end,\\r\\n            reverse = function(arrayTable)\\r\\n                local result = {}\\r\\n                for i = #arrayTable, 1, -1 do\\r\\n                    result[#result + 1] = arrayTable[i]\\r\\n                end\\r\\n                return result;\\r\\n            end,\\r\\n            map = function(table, func)\\r\\n                local result = {}\\r\\n                for key, value in pairs(table) do\\r\\n                    result[key] = func(value, key, table)\\r\\n                end\\r\\n                return result;\\r\\n            end,\\r\\n            filter = function(table, func)\\r\\n                local result = {}\\r\\n                for key, value in pairs(table) do\\r\\n                    if func(value, key, table) then\\r\\n                        result[key] = table[key]\\r\\n                    end\\r\\n                end\\r\\n                return result;\\r\\n            end,\\r\\n            contains = function(table, val)\\r\\n                for key, value in pairs(table) do\\r\\n                    if value == val then\\r\\n                        return true\\r\\n                    end\\r\\n                end\\r\\n                return false\\r\\n            end,\\r\\n            find = function(table, predicate)\\r\\n                for key, value in pairs(table) do\\r\\n                    if predicate(value, key, table) then\\r\\n                        return value\\r\\n                    end\\r\\n                end\\r\\n                return nil\\r\\n            end,\\r\\n            indexOf = function(table, element)\\r\\n                for key, value in pairs(table) do\\r\\n                    if value == element then\\r\\n                        return key\\r\\n                    end\\r\\n                end\\r\\n                return nil\\r\\n            end,\\r\\n            getFromPath = function(table, path)\\r\\n                local prev = table;\\r\\n\\r\\n                for key in path:gmatch(\\\"([^/]+)\\\") do\\r\\n                    if key == \\\".\\\" then\\r\\n                        return prev;\\r\\n                    end\\r\\n\\r\\n                    local value = prev[key];\\r\\n\\r\\n                    if value == nil then\\r\\n                        return nil;\\r\\n                    end\\r\\n\\r\\n                    prev = value;\\r\\n                end\\r\\n\\r\\n                return prev;\\r\\n            end,\\r\\n            combine = function(a, b)\\r\\n                local result = {}\\r\\n                for key, value in pairs(a) do\\r\\n                    result[key] = value\\r\\n                end\\r\\n                for key, value in pairs(b) do\\r\\n                    result[key] = value\\r\\n                end\\r\\n                return result;\\r\\n            end,\\r\\n            toArray = function(table)\\r\\n                local result = {}\\r\\n                for key, value in pairs(table) do\\r\\n                    result[#result + 1] = value\\r\\n                end\\r\\n                return result;\\r\\n            end\\r\\n        },\\r\\n        string = {\\r\\n            findIndex = function(str, pattern, init, plain)\\r\\n                if init == nil then init = 1 end\\r\\n                if plain == nil then plain = false end\\r\\n\\r\\n                local index = init;\\r\\n                return function()\\r\\n                    index = str:find(pattern, index + 1, plain);\\r\\n                    return index;\\r\\n                end\\r\\n            end,\\r\\n            findRevIndex = function(str, pattern, init, plain)\\r\\n                if init == nil then init = 1 end\\r\\n                if plain == nil then plain = false end\\r\\n\\r\\n                local index = init;\\r\\n                return function()\\r\\n                    index = str:reverse():find(pattern, index + 1, plain);\\r\\n                    return #str - index + 1;\\r\\n                end\\r\\n            end,\\r\\n            trim = function(str)\\r\\n                return str:gsub(\\\"%s+\\\", \\\" \\\"):match(\\\"^%s*(.*)\\\"):match(\\\"(.-)%s*$\\\")\\r\\n            end,\\r\\n            peek = function(str, index, size)\\r\\n                if index == nil or str == nil then\\r\\n                    return nil\\r\\n                end\\r\\n                return util.string.trim(str:sub(index - size, index + size))\\r\\n            end,\\r\\n            startsWith = function(str, text)\\r\\n                return str:sub(1, #text) == text\\r\\n            end,\\r\\n            endsWith = function(str, text)\\r\\n                return text == \\\"\\\" or str:sub( -#text) == text\\r\\n            end,\\r\\n            toByteArray = function(str)\\r\\n                local result = {};\\r\\n\\r\\n                for i = 0, #str, 1 do\\r\\n                    table.insert(result, i, str:byte(i))\\r\\n                end\\r\\n\\r\\n                return result;\\r\\n            end,\\r\\n            fromByteArray = function(array)\\r\\n                local result = \\\"\\\";\\r\\n\\r\\n                for key, value in pairs(array) do\\r\\n                    result = result .. (tostring(value):char())\\r\\n                end\\r\\n\\r\\n                return result;\\r\\n            end\\r\\n        },\\r\\n        draw = {\\r\\n            createMaterial = function(sText, fgrcol, bkgcol)\\r\\n                if sText == nil then sText = \\\"*\\\" end\\r\\n                if fgrcol == nil then fgrcol = colors.white; end\\r\\n                if bkgcol == nil then bkgcol = colors.black; end\\r\\n\\r\\n                local index = 0;\\r\\n\\r\\n                return {\\r\\n                    fgrcol = fgrcol,\\r\\n                    bkgcol = bkgcol,\\r\\n                    getNext = function()\\r\\n                        if index >= #sText then\\r\\n                            index = 0;\\r\\n                        end\\r\\n                        index = index + 1;\\r\\n                        return sText:sub(index, index)\\r\\n                    end,\\r\\n                    handleColor = function(wind, func)\\r\\n                        local bkg = wind.getBackgroundColor();\\r\\n                        local fgr = wind.getTextColor();\\r\\n\\r\\n                        wind.setBackgroundColor(bkgcol)\\r\\n                        wind.setTextColor(fgrcol)\\r\\n\\r\\n                        func()\\r\\n\\r\\n                        wind.setBackgroundColor(bkg)\\r\\n                        wind.setTextColor(fgr)\\r\\n                    end,\\r\\n                    clone = function()\\r\\n                        return util.draw.createMaterial(sText, fgrcol, bkgcol);\\r\\n                    end\\r\\n                }\\r\\n            end,\\r\\n            circle = function(wind, x, y, radius, startDeg, endDeg, material)\\r\\n                if material == nil then material = util.draw.createMaterial(); end\\r\\n                if endDeg == nil then endDeg = 360 end\\r\\n                if startDeg == nil then startDeg = 0; end\\r\\n\\r\\n                material.handleColor(wind, function()\\r\\n                    local step = FindClosestCircleStep(radius) / math.pi;\\r\\n\\r\\n                    for i = startDeg, endDeg, step do\\r\\n                        local angle = i * math.pi / 180;\\r\\n                        local xPos = math.floor(x + (radius * math.cos(angle)))\\r\\n                        local yPos = math.floor(y + (radius * math.sin(angle)))\\r\\n\\r\\n                        wind.setCursorPos(xPos, yPos)\\r\\n                        wind.write(material.getNext())\\r\\n                    end\\r\\n                end)\\r\\n            end,\\r\\n            line = function(wind, ax, ay, bx, by, material)\\r\\n                if material == nil then material = util.draw.createMaterial(); end\\r\\n\\r\\n                material.handleColor(wind, function()\\r\\n                    ax = math.floor(ax)\\r\\n                    ay = math.floor(ay)\\r\\n                    bx = math.floor(bx)\\r\\n                    by = math.floor(by)\\r\\n\\r\\n                    local dx = math.abs(bx - ax)\\r\\n                    local dy = math.abs(by - ay)\\r\\n                    local sx = (ax < bx) and 1 or -1\\r\\n                    local sy = (ay < by) and 1 or -1\\r\\n                    local err = dx - dy\\r\\n\\r\\n                    while true do\\r\\n                        wind.setCursorPos(ax, ay)\\r\\n                        wind.write(material.getNext())\\r\\n\\r\\n                        if (ax == bx and ay == by) then\\r\\n                            break\\r\\n                        end\\r\\n\\r\\n                        local e2 = 2 * err\\r\\n                        if (e2 > -dy) then\\r\\n                            err = err - dy;\\r\\n                            ax = math.floor(ax + sx);\\r\\n                        end\\r\\n\\r\\n                        if (e2 < dx) then\\r\\n                            err = err + dx;\\r\\n                            ay = math.floor(ay + sy);\\r\\n                        end\\r\\n                    end\\r\\n                end)\\r\\n            end,\\r\\n            polygon = function(wind, array, open, material)\\r\\n                if material == nil then material = util.draw.createMaterial(); end\\r\\n                if open == nil then open = false end\\r\\n\\r\\n                for i = 1, #array - 2, 2 do\\r\\n                    util.draw.line(wind, array[i], array[i + 1], array[i + 2], array[i + 3], material)\\r\\n                end\\r\\n\\r\\n                if not open then\\r\\n                    util.draw.line(wind, array[#array - 1], array[#array], array[1], array[2], material)\\r\\n                end\\r\\n            end,\\r\\n            rect = function(wind, ax, ay, bx, by, material)\\r\\n                if material == nil then material = util.draw.createMaterial(); end\\r\\n\\r\\n                local minX = math.min(ax, bx)\\r\\n                local minY = math.min(ay, by)\\r\\n                local maxX = math.max(ax, bx)\\r\\n                local maxY = math.max(ay, by)\\r\\n\\r\\n                material.handleColor(wind, function()\\r\\n                    for x = minX, maxX, 1 do\\r\\n                        for y = minY, maxY, 1 do\\r\\n                            wind.setCursorPos(x, y)\\r\\n                            wind.write(material.getNext())\\r\\n                        end\\r\\n                    end\\r\\n                end)\\r\\n            end\\r\\n        }\\r\\n    }\\r\\nend\\r\\n\\r\\n_G.util = UTILITY_FUNC();\\r\\n\"},{\"a\":\"system\\\\fossil\\\\LICENSE\",\"b\":\"MIT License\\r\\n\\r\\nCopyright (c) 2023 StoneTrench\\r\\n\\r\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\r\\nof this software and associated documentation files (the \\\"Software\\\"), to deal\\r\\nin the Software without restriction, including without limitation the rights\\r\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\r\\ncopies of the Software, and to permit persons to whom the Software is\\r\\nfurnished to do so, subject to the following conditions:\\r\\n\\r\\nThe above copyright notice and this permission notice shall be included in all\\r\\ncopies or substantial portions of the Software.\\r\\n\\r\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\r\\nSOFTWARE.\"},{\"a\":\"system\\\\fossil\\\\programs\\\\.pkgListAddr\",\"b\":\"{\\r\\n    \\\"https://github.com/StoneTrench/ComputerCraft/blob/master/packages.list\\\"\\r\\n}\"},{\"a\":\"system\\\\fossil\\\\programs\\\\git.lua\",\"b\":\"local function git_FUNC()\\r\\n    if not http then\\r\\n        error(\\\"Git requires the http API\\\")\\r\\n        error(\\\"Set http.enabled to true in the config\\\")\\r\\n        return\\r\\n    end\\r\\n\\r\\n    return {\\r\\n        get = function(address)\\r\\n            local rawPath = \\\"https://raw.githubusercontent.com/\\\" ..\\r\\n                address:gsub(\\\"https://github.com/\\\", \\\"\\\"):gsub(\\\"https://raw.githubusercontent.com/\\\", \\\"\\\"):gsub(\\r\\n                    \\\"blob/\\\", \\\"\\\");\\r\\n\\r\\n            local response = http.get(rawPath)\\r\\n\\r\\n            if response then\\r\\n                local headers = response.getResponseHeaders()\\r\\n                if not headers[\\\"Content-Type\\\"] or not\\r\\n                    (headers[\\\"Content-Type\\\"]:find(\\\"^text/plain\\\") or headers[\\\"Content-Type\\\"]:find(\\\"^application/octet-stream\\\")) then\\r\\n                    return nil;\\r\\n                end\\r\\n\\r\\n                local data = response.readAll()\\r\\n                response.close()\\r\\n                return data;\\r\\n            end\\r\\n            return nil;\\r\\n        end,\\r\\n        run = function(address, ...)\\r\\n            local data = git.get(address)\\r\\n\\r\\n            if data == nil then\\r\\n                return false;\\r\\n            end\\r\\n\\r\\n            local func, err = load(data, address, \\\"t\\\", _ENV)\\r\\n\\r\\n            if not func then\\r\\n                error(err)\\r\\n            end\\r\\n\\r\\n            return pcall(func, select(3, ...))\\r\\n        end\\r\\n    }\\r\\nend\\r\\n\\r\\ngit = git_FUNC();\\r\\n\"},{\"a\":\"system\\\\fossil\\\\programs\\\\pkgmngr.lua\",\"b\":\"local function pkgmngr_FUNC()\\r\\n    require(F.PATHS.DIR.programs .. \\\"git\\\")\\r\\n    require(F.PATHS.DIR.programs .. \\\"sziplib\\\")\\r\\n\\r\\n    local packageFileName = \\\"package.json\\\";\\r\\n    local packageAddrassesFile = F.PATHS.DIR.programs .. \\\".pkgListAddr\\\"\\r\\n\\r\\n    local packageListAddresses = textutils.unserialise(util.fs.readFile(packageAddrassesFile))\\r\\n\\r\\n    local packageList = {};\\r\\n\\r\\n    return {\\r\\n        packageListAddress = {\\r\\n            remove = function(index)\\r\\n                table.remove(packageListAddresses, index)\\r\\n                util.fs.writeFile(packageAddrassesFile, textutils.serialise(packageListAddresses))\\r\\n            end,\\r\\n            add = function(address)\\r\\n                table.insert(packageListAddresses, address)\\r\\n                util.fs.writeFile(packageAddrassesFile, textutils.serialise(packageListAddresses))\\r\\n            end,\\r\\n            get = function()\\r\\n                return util.clone(packageListAddresses)\\r\\n            end,\\r\\n        },\\r\\n        packageList = {\\r\\n            refresh = function()\\r\\n                packageList = util.table.reduce(util.table.map(packageListAddresses, function(e)\\r\\n                        local rec = git.get(e)\\r\\n\\r\\n                        if rec == nil then\\r\\n                            return { \\\"Failed to get package list.\\\" }\\r\\n                        end\\r\\n\\r\\n                        local result = {};\\r\\n\\r\\n                        for line in rec:gmatch(\\\"([^\\\\n]+)\\\") do\\r\\n                            local meta = pkgmngr.packageList.getPackageMetadata(line);\\r\\n                            if meta ~= nil then\\r\\n                                table.insert(result, {\\r\\n                                    meta = meta,\\r\\n                                    address = line,\\r\\n                                })\\r\\n                            end\\r\\n                        end\\r\\n\\r\\n                        return result;\\r\\n                    end), function(a, b)\\r\\n                        return util.table.combine(a, b)\\r\\n                    end)\\r\\n            end,\\r\\n            get = function()\\r\\n                return util.clone(packageList)\\r\\n            end,\\r\\n            getPackageMetadata = function(address)\\r\\n                local rec = git.get(address);\\r\\n\\r\\n                if rec == nil then\\r\\n                    return nil;\\r\\n                end\\r\\n\\r\\n                local packagef = textutils.unserializeJSON(SZIP.getFileFromFiles(SZIP.decompress(rec), packageFileName)\\r\\n                    .content);\\r\\n                return packagef;\\r\\n            end,\\r\\n            findByName = function(name)\\r\\n                return util.table.toArray(util.table.filter(pkgmngr.packageList.get(), function(e)\\r\\n                        local result = false;\\r\\n                        if e.meta.name ~= nil then\\r\\n                            result = e.meta.name:match(name)\\r\\n                        end\\r\\n                        return result;\\r\\n                    end))\\r\\n            end,\\r\\n            findByTag = function(tag)\\r\\n                return util.table.toArray(util.table.filter(pkgmngr.packageList.get(), function(e)\\r\\n                        local result = false;\\r\\n                        if e.meta.tags ~= nil then\\r\\n                            util.table.contains(e.meta.tags, tag)\\r\\n                        end\\r\\n                        return result;\\r\\n                    end))\\r\\n            end,\\r\\n            install = function(name, silent)\\r\\n                if silent == nil then\\r\\n                    silent = true;\\r\\n                end\\r\\n\\r\\n                if not silent then\\r\\n                    console.log(\\\"Installing \\\" .. name .. \\\"...\\\")\\r\\n                end\\r\\n\\r\\n                local rec = git.get(pkgmngr.packageList.findByName(name)[1].address)\\r\\n\\r\\n                if rec == nil then\\r\\n                    error(name .. \\\" not found!\\\")\\r\\n                end\\r\\n                local files = SZIP.decompress(rec)\\r\\n\\r\\n                local packagefZIP = SZIP.getFileFromFiles(files, packageFileName);\\r\\n                if packagefZIP == nil then\\r\\n                    error(packageFileName .. \\\" not found!\\\")\\r\\n                end\\r\\n                SZIP.unserializeFiles(files, F.PATHS.DIR.packages)\\r\\n\\r\\n                local packagef = textutils.unserializeJSON(packagefZIP.content)\\r\\n                local packagePath = fs.combine(F.PATHS.DIR.packages, fs.getDir(packagefZIP.path));\\r\\n\\r\\n                if packagef.commands then\\r\\n                    console.log(\\\"Installing commands.\\\")\\r\\n                    for key, value in pairs(packagef.commands) do\\r\\n                        local cmd_src = fs.combine(packagePath, value);\\r\\n                        local cmd_dest = fs.combine(F.PATHS.DIR.commands, value);\\r\\n\\r\\n                        if not fs.exists(cmd_dest) then\\r\\n                            fs.copy(cmd_src, cmd_dest)\\r\\n                            if not silent then\\r\\n                                console.log(\\\"\\\\t\\\" .. value .. \\\"...\\\")\\r\\n                            end\\r\\n                        else\\r\\n                            if not silent then\\r\\n                                console.warn(\\\"\\\\t\\\" .. value .. \\\" already found in destination!\\\")\\r\\n                            end\\r\\n                        end\\r\\n                    end\\r\\n                end\\r\\n                if packagef.dependencies then\\r\\n                    for key, value in pairs(packagef.dependencies) do\\r\\n                        pkgmngr.packageList.install(value, true)\\r\\n                        if not silent then\\r\\n                            console.log(\\\"Installing dependency \\\" .. value .. \\\"...\\\")\\r\\n                        end\\r\\n                    end\\r\\n                end\\r\\n\\r\\n                if not silent then\\r\\n                    console.log((packagef.displayName or packagef.name) .. \\\" installed.\\\")\\r\\n                end\\r\\n\\r\\n                return packagef\\r\\n            end\\r\\n        },\\r\\n        packageLocal = {\\r\\n            scanAll = function()\\r\\n                local packages = pkgmngr.packageLocal.getPaths();\\r\\n\\r\\n                local result = {};\\r\\n\\r\\n                for key, value in pairs(packages) do\\r\\n                    local meta, name, status, message = pkgmngr.packageLocal.scan(value)\\r\\n                    result[name] = {\\r\\n                        meta = meta,\\r\\n                        message = message,\\r\\n                        status = status,\\r\\n                    }\\r\\n                end\\r\\n\\r\\n                return result;\\r\\n            end,\\r\\n            scan = function(packageDir)\\r\\n                local meta = textutils.unserialiseJSON(util.fs.readFile(packageDir));\\r\\n\\r\\n                local message = \\\"\\\";\\r\\n                local status = \\\"\\\";\\r\\n                local name = nil;\\r\\n\\r\\n                if meta then\\r\\n                    local check = {\\r\\n                        \\\"name\\\",\\r\\n                        \\\"description\\\",\\r\\n                        \\\"version\\\",\\r\\n                        \\\"authors\\\",\\r\\n                    };\\r\\n                    local missing = {}\\r\\n\\r\\n                    for key, value in pairs(check) do\\r\\n                        if not meta[value] then\\r\\n                            table.insert(missing, value)\\r\\n                        end\\r\\n                    end\\r\\n\\r\\n                    name = (meta.displayName or meta.name or fs.getName(packageDir));\\r\\n                    if #missing > 0 then\\r\\n                        message = \\\"Package \\\" .. name .. \\\" is missing: \\\" .. table.concat(missing, \\\", \\\") .. \\\"!\\\";\\r\\n                        status = \\\"parial\\\";\\r\\n                    else\\r\\n                        message = \\\"Scanned package \\\" .. name .. \\\".\\\";\\r\\n                        status = \\\"success\\\";\\r\\n                    end\\r\\n                else\\r\\n                    name = fs.getName(packageDir);\\r\\n                    message = \\\"Failed to scan package \\\" .. name .. \\\"!\\\";\\r\\n                    status = \\\"failed\\\";\\r\\n                end\\r\\n\\r\\n                return meta, name, status, message;\\r\\n            end,\\r\\n            getPaths = function()\\r\\n                return util.table.map(util.fs.findFiles(F.PATHS.DIR.packages, packageFileName), function(e)\\r\\n                        return e\\r\\n                    end)\\r\\n            end,\\r\\n            find = function(name)\\r\\n                return util.table.toArray(util.table.filter(pkgmngr.packageLocal.getPaths(), function(e)\\r\\n                        return textutils.unserializeJSON(util.fs.readFile(e)).name:match(name);\\r\\n                    end))\\r\\n            end,\\r\\n            uninstall = function(name)\\r\\n                local packagePath = pkgmngr.packageLocal.find(name)[1]\\r\\n                local packagef = util.fs.readFile(packagePath)\\r\\n\\r\\n                if packagef.commands then\\r\\n                    for key, value in pairs(packagef.commands) do\\r\\n                        fs.delete(fs.combine(F.PATHS.DIR.commands, value))\\r\\n                    end\\r\\n                end\\r\\n\\r\\n                fs.delete(fs.getDir(packagePath))\\r\\n            end,\\r\\n            compilePackage = function(directory, silent)\\r\\n                if silent == nil then\\r\\n                    silent = true;\\r\\n                end\\r\\n                directory = shell.resolve(directory);\\r\\n\\r\\n                if not fs.exists(directory) then\\r\\n                    error(directory .. \\\" doesn't exist!\\\")\\r\\n                end\\r\\n\\r\\n                local meta, name, status, message = pkgmngr.packageLocal.scan(directory)\\r\\n\\r\\n                if status == \\\"failed\\\" then\\r\\n                    error(message);\\r\\n                end\\r\\n                if not silent then\\r\\n                    if status == \\\"partial\\\" then\\r\\n                        console.warn(message)\\r\\n                    end\\r\\n                    if status == \\\"success\\\" then\\r\\n                        console.log(message)\\r\\n                    end\\r\\n                end\\r\\n\\r\\n                if not silent then\\r\\n                    console.warn(\\r\\n                        \\\"Warning the compiler will move the command file into the package and overwite it if there's one!\\\")\\r\\n                    console.warn(\\\"Do you still wish to proceed? (y/n)\\\")\\r\\n                    console.write(\\\"\\\\t\\\")\\r\\n                    local option = console.input.read({ \\\"y\\\", \\\"n\\\" }, nil):lower()\\r\\n                    if option == \\\"n\\\" then\\r\\n                        console.log(\\\"Cancelled.\\\")\\r\\n                        return;\\r\\n                    elseif option == \\\"y\\\" then\\r\\n                        console.log(\\\"Continuing.\\\")\\r\\n                    end\\r\\n                end\\r\\n\\r\\n                if meta.commands then\\r\\n                    if not silent then\\r\\n                        console.log(\\\"Copying commands.\\\")\\r\\n                    end\\r\\n                    for key, value in pairs(meta.commands) do\\r\\n                        local cmd_src = fs.combine(F.PATHS.DIR.commands, value);\\r\\n                        local cmd_dest = fs.combine(directory, value);\\r\\n\\r\\n                        fs.delete(cmd_dest)\\r\\n                        fs.copy(cmd_src, cmd_dest)\\r\\n                    end\\r\\n                end\\r\\n\\r\\n                local fileName = name;\\r\\n\\r\\n                if meta.version then\\r\\n                    fileName = fileName .. \\\"-\\\" .. meta.version\\r\\n                end\\r\\n\\r\\n                fileName = fileName .. \\\".spac\\\"\\r\\n                if not silent then\\r\\n                    console.log(\\\"Packing \\\" .. fileName)\\r\\n                end\\r\\n\\r\\n                SZIP.packFiles(directory, fs.combine(directory, \\\"../\\\" .. fileName))\\r\\n                if not silent then\\r\\n                    console.log(\\\"Done.\\\")\\r\\n                end\\r\\n            end\\r\\n        },\\r\\n    }\\r\\nend\\r\\n\\r\\npkgmngr = pkgmngr_FUNC();\\r\\npkgmngr.packageList.refresh();\\r\\n\"},{\"a\":\"system\\\\fossil\\\\programs\\\\sziplib.lua\",\"b\":\"local function SZIP_FUNC()\\r\\n    return {\\r\\n        getFileExtention = function ()\\r\\n            return \\\".szip\\\"\\r\\n        end,\\r\\n        packFiles = function(directory, destination)\\r\\n            if destination == nil then destination = fs.getDir(directory) .. \\\"/\\\" end\\r\\n\\r\\n            directory = shell.resolve(directory);\\r\\n\\r\\n            if not fs.exists(directory) then\\r\\n                error(\\\"The directory does not exist!\\\")\\r\\n            end\\r\\n            if not fs.isDir(directory) then\\r\\n                error(\\\"The path was not a directory!\\\")\\r\\n            end\\r\\n\\r\\n            local RedData = SZIP.compress(SZIP.serializeFiles(directory));\\r\\n            if RedData == nil then\\r\\n                error(\\\"Failed to compress!\\\")\\r\\n            end\\r\\n\\r\\n            if destination:sub(#destination - 5, #destination) ~= SZIP.getFileExtention() then\\r\\n                destination = destination .. SZIP.getFileExtention()\\r\\n            end\\r\\n\\r\\n            -- if fs.exists(destination) then\\r\\n            --     error(\\\"The destination already exists!\\\")\\r\\n            -- end\\r\\n\\r\\n            local fileStream = fs.open(destination, \\\"w\\\")\\r\\n            fileStream.write(RedData)\\r\\n            fileStream.close()\\r\\n        end,\\r\\n        unpackFiles = function(packagePath, destination)\\r\\n            packagePath = shell.resolve(packagePath);\\r\\n            destination = shell.resolve(destination);\\r\\n\\r\\n            if not fs.exists(packagePath) then\\r\\n                error(\\\"The file does not exist!\\\")\\r\\n            end\\r\\n            if fs.isDir(packagePath) then\\r\\n                error(\\\"The path was a directory!\\\")\\r\\n            end\\r\\n\\r\\n            local fileStream = fs.open(packagePath, \\\"r\\\")\\r\\n            local data = SZIP.decompress(fileStream.readAll())\\r\\n            fileStream.close();\\r\\n\\r\\n            SZIP.unserializeFiles(data, destination)\\r\\n        end,\\r\\n        compress = function(data)\\r\\n            return textutils.serializeJSON(data);\\r\\n        end,\\r\\n        decompress = function(data)\\r\\n            return textutils.unserializeJSON(data);\\r\\n        end,\\r\\n        unserializeFiles = function(data, destination)\\r\\n            destination = shell.resolve(destination);\\r\\n\\r\\n            for key, value in pairs(data.files) do\\r\\n                fs.makeDir(fs.getDir(fs.combine(destination, value.path)))\\r\\n\\r\\n                fileStream = fs.open(fs.combine(destination, value.path), \\\"w\\\");\\r\\n                fileStream.write(value.content);\\r\\n                fileStream.close();\\r\\n            end\\r\\n        end,\\r\\n        serializeFiles = function(directory)\\r\\n            directory = shell.resolve(directory);\\r\\n\\r\\n            local filesToPack = {};\\r\\n\\r\\n            local function tree(dirPath)\\r\\n                local subPaths = fs.list(dirPath)\\r\\n\\r\\n                for i = 1, #subPaths, 1 do\\r\\n                    local path = fs.combine(dirPath, subPaths[i]);\\r\\n\\r\\n                    if fs.isDir(path) then\\r\\n                        tree(path)\\r\\n                    else\\r\\n                        table.insert(filesToPack, path)\\r\\n                    end\\r\\n                end\\r\\n            end\\r\\n            tree(directory)\\r\\n\\r\\n            local data = {\\r\\n                files = {}\\r\\n            }\\r\\n\\r\\n            for i = 1, #filesToPack, 1 do\\r\\n                local fileStream = fs.open(filesToPack[i], \\\"r\\\")\\r\\n                table.insert(data.files, {\\r\\n                    path = filesToPack[i]:gsub(fs.getDir(directory), \\\"\\\"),\\r\\n                    content = fileStream.readAll()\\r\\n                })\\r\\n                fileStream.close();\\r\\n            end\\r\\n\\r\\n            return data;\\r\\n        end,\\r\\n        getFileFromFiles = function(serializedFile, pattern)\\r\\n            for key, value in pairs(serializedFile.files) do\\r\\n                if value.path:match(pattern) then\\r\\n                    return value\\r\\n                end\\r\\n            end\\r\\n\\r\\n            return nil\\r\\n        end\\r\\n    }\\r\\nend\\r\\n\\r\\nSZIP = SZIP_FUNC();\\r\\n\"}]")) do fs.makeDir(fs.getDir(b.a)) local c = fs.open(b.a, "w") c.write(b.b) c.close();end;fs.makeDir("./startup/");local d = fs.open("./startup/startup.lua", "w");d.write("require(\".system.fossil.bootload\")");d.close();