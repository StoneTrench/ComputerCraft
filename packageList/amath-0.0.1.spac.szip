{"files":[{"content":"local function AMATH_FUNC()\n    return {\n        PerspectiveMatrix = function(width, height, near, far, fov)\n            return {\n                (height / width) / math.tan(fov * 0.5), 0, 0, 0,\n                0, 1 / (math.tan(fov * 0.5)), 0, 0,\n                0, 0, -far / (far - near), -1,\n                0, 0, -far * near / (far - near), -1\n            }\n        end,\n        TransformMatrix = function(position, rotation, scale)\n            return {\n                (height / width) / math.tan(fov * 0.5), 0, 0, 0,\n                0, 1 / (math.tan(fov * 0.5)), 0, 0,\n                0, 0, -far / (far - near), -1,\n                0, 0, -far * near / (far - near), -1\n            }\n        end,\n        VecXU = {\n            Add = function(vecX_a, vecX_b)\n                return util.table.map(vecX_a, function(e, i)\n                        return e + vecX_b[i];\n                    end)\n            end,\n            Sub = function(vecX_a, vecX_b)\n                return util.table.map(vecX_a, function(e, i)\n                        return e - vecX_b[i];\n                    end)\n            end,\n            Dot = function(vecX_a, vecX_b)\n                return util.table.reduce(util.table.map(vecX_a, function(e, i)\n                        return e * vecX_b[i];\n                    end), function(a, b)\n                        return a + b\n                    end)\n            end,\n            Scale = function(vecX, scalar)\n                return util.table.map(vecX, function(e, i)\n                        return e * scalar;\n                    end)\n            end,\n            Length = function(vecX)\n                return math.sqrt(util.table.reduce(util.table.map(vecX, function(e, i)\n                        return e * e;\n                    end), function(a, b)\n                        return a + b\n                    end))\n            end,\n            Normalize = function(vecX)\n                return AMATH.VecXU.Scale(vecX, 1 / AMATH.VecXU.Length(vecX));\n            end,\n            Cross = function(vecX_a, vecX_b)\n                if #vecX_a == 3 and #vecX_b == 3 then\n                    return AMATH.Vec3U.Cross(vecX_a, vecX_b);\n                end\n                return nil\n            end\n        },\n        Vec3U = {\n            MultiplyMatrix = function(vec3, matrix3x3)\n                local x, y, z = table.unpack(vec3)\n\n                return {\n                    x * matrix3x3[1] + y * matrix3x3[4] + z * matrix3x3[7],\n                    x * matrix3x3[2] + y * matrix3x3[5] + z * matrix3x3[8],\n                    x * matrix3x3[3] + y * matrix3x3[6] + z * matrix3x3[9]\n                }\n            end,\n            Cross = function(vec3_a, vec3_b)\n                return {\n                    vec3_a[2] * vec3_b[3] - vec3_a[3] * vec3_b[2],\n                    vec3_a[3] * vec3_b[1] - vec3_a[1] * vec3_b[3],\n                    vec3_a[1] * vec3_b[2] - vec3_a[2] * vec3_b[1]\n                }\n            end,\n            Dot = function(vec3_a, vec3_b)\n                return vec3_a[1] * vec3_b[1] + vec3_a[2] * vec3_b[2] + vec3_a[3] * vec3_b[3]\n            end,\n            Length = function(vec3)\n                return math.sqrt(vec3[1] * vec3[1] + vec3[2] * vec3[2] + vec3[3] * vec3[3])\n            end,\n            Scale = function(vec3, number)\n                return { vec3[1] * number, vec3[2] * number, vec3[3] * number }\n            end,\n            Normalize = function(vec3)\n                return AMATH.Vec3U.Scale(vec3, 1 / AMATH.Vec3U.Length(vec3));\n            end,\n            Offset = function(vec3, x, y, z)\n                return { vec3[1] + x, vec3[2] + y, vec3[3] + z }\n            end\n        },\n        Vec4U = {\n            MultiplyMatrix = function(vec4, matrix4x4)\n                local x, y, z, w = table.unpack(vec4)\n\n                return {\n                    x * matrix4x4[1] + y * matrix4x4[5] + z * matrix4x4[9] + w * matrix4x4[13],\n                    x * matrix4x4[2] + y * matrix4x4[6] + z * matrix4x4[10] + w * matrix4x4[14],\n                    x * matrix4x4[3] + y * matrix4x4[7] + z * matrix4x4[11] + w * matrix4x4[15],\n                    x * matrix4x4[4] + y * matrix4x4[8] + z * matrix4x4[12] + w * matrix4x4[16]\n                }\n            end,\n            Dot = function(vec4_a, vec4_b)\n                return vec4_a[1] * vec4_b[1] + vec4_a[2] * vec4_b[2] + vec4_a[3] * vec4_b[3] + vec4_a[4] * vec4_b[4]\n            end,\n            Length = function(vec4)\n                return math.sqrt(vec4[1] * vec4[1] + vec4[2] * vec4[2] + vec4[3] * vec4[3] + vec4[4] * vec4[4])\n            end,\n            Scale = function(vec4, number)\n                return { vec4[1] * number, vec4[2] * number, vec4[3] * number, vec4[4] * number }\n            end,\n            Normalize = function(vec4)\n                return AMATH.Vec4U.Scale(vec4, 1 / AMATH.Vec4U.Length(vec4));\n            end,\n            Offset = function(vec4, x, y, z, w)\n                return { vec4[1] + x, vec4[2] + y, vec4[3] + z, vec4[4] + w }\n            end\n        }\n    }\nend\n\nAMATH = AMATH_FUNC();\n","path":"/amath/amath.lua"},{"content":"{\n    \"name\": \"amath\",\n    \"displayName\": \"Advanced Math\",\n    \"description\": \"A library that has more math.\",\n    \"version\": \"0.0.1\",\n    \"authors\": [\n        \"StoneTrench\"\n    ],\n    \"tags\": [\n        \"lib\",\n        \"library\"\n    ]\n}","path":"/amath/package.json"}]}